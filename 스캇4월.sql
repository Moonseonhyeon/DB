SELECT *
FROM EMP;

SELECT ENAME,S1, S2, DECODE(S1, S2, NO-1, NO)
FROM(
SELECT ENAME, SAL "S1", LAG(SAL, 1, 0) OVER(ORDER BY SAL DESC)"S2",ROWNUM "NO"
FROM
(
SELECT ENAME, SAL
FROM EMP
ORDER BY SAL DESC
));
--이렇게 서브쿼리로 SELECT많이 하게 되니까 별로에요 실시간작업이면 느리면 안되니까요

SELECT ENAME, SAL, LAG(SAL, 1, 0) OVER(ORDER BY SAL DESC)
FROM EMP;

SELECT ENAME, SAL, RANK() OVER (ORDER BY SAL DESC)
FROM EMP;

--키순 
SELECT NAME, HEIGHT, RANK() OVER (ORDER BY HEIGHT DESC)
FROM STUDENT;
--학년별 키 순위를 구하시오.
--1번째 방법 UNION ALL로 
SELECT GRADE, NAME, HEIGHT, RANK() OVER(ORDER BY HEIGHT DESC)
FROM STUDENT
WHERE GRADE =1
UNION ALL
SELECT GRADE, NAME, HEIGHT, RANK() OVER(ORDER BY HEIGHT DESC)
FROM STUDENT
WHERE GRADE =2
UNION ALL
SELECT GRADE, NAME, HEIGHT, RANK() OVER(ORDER BY HEIGHT DESC)
FROM STUDENT
WHERE GRADE =3
UNION ALL
SELECT GRADE, NAME, HEIGHT, RANK() OVER(ORDER BY HEIGHT DESC)
FROM STUDENT
WHERE GRADE =4;
----2번째 방법 PARTITION BY로 
SELECT GRADE, NAME, HEIGHT, RANK() OVER(PARTITION BY GRADE ORDER BY HEIGHT DESC)
FROM STUDENT;
----DENSE_RANK 혼자 해보면 된다
SELECT EMPNO, ENAME, SAL, DEPTNO, RANK() OVER( PARTITION BY DEPTNO, JOB ORDER BY SAL DESC) "RANK"
FROM EMP;
----ROW_NUMER() 혼자 할 수있다....
--JOIN 
--행 14
SELECT *
FROM EMP;
--열 4
SELECT *
FROM DEPT;
--56=14*4 <- CERTESIAN JOIN
SELECT * 
FROM EMP, DEPT
ORDER BY ENAME;
--INNER JOIN (오라클)
SELECT E.ENAME, E.DEPTNO, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;

SELECT *
FROM DEPT D, EMP E
WHERE D.DEPTNO = E.DEPTNO;

SELECT * FROM DEPT;
SELECT * FROM EMP;

DELETE FROM DEPT WHERE DEPTNO = 20;

ROLLBACK;
--DEPTNO 왜례키 참조하고 있음.

--RIGHT OUTER JOIN : +가 붙은 쪽에 null 값이 나오고 기준되서 다 보고 싶은 쪽이 LEFT, RIGHT
SELECT *
FROM EMP E, DEPT D
WHERE E.DEPTNO(+) = D.DEPTNO;

--PROFESSOR, STUDENT
SELECT * 
FROM PROFESSOR P , STUDENT S
WHERE P.PROFNO = S.PROFNO;

SELECT S.NAME, P.NAME
FROM STUDENT S, PROFESSOR P 
WHERE S.PROFNO = P.PROFNO;

--DDL (테이블 삭제(DROP), 수정(ALTER), 생성(CREATE))
CREATE TABLE REPLY(
    ID NUMBER,
    CONTENT VARCHAR2(200) NOT NULL,
    boardId number,
    userId number,
    CONSTRAINT REPLY_PK PRIMARY KEY (ID),
    CONSTRAINT REPLY_FK_BOARD_ID FOREIGN KEY (BOARDID)REFERENCES BOARD(ID), 
    CONSTRAINT REPLY_FK_USER_ID FOREIGN KEY (USERID)REFERENCES USERS(ID)
);

CREATE SEQUENCE USERS_SEQ
INCREMENT BY 1
START WITH 1;

CREATE SEQUENCE BOARD_SEQ
INCREMENT BY 1
START WITH 1;

CREATE SEQUENCE REPLY_SEQ
INCREMENT BY 1
START WITH 1;

--USERS, BOARD, REPLY
--DML (데이터 조작어)
INSERT INTO USERS--(ID, USERNAME, EMAIL)이렇게 다 넣을거면 생략가능하다
VALUES(USERS_SEQ.nextval, 'SSAR', 'SSAR@NATE.COM');

INSERT INTO USERS
VALUES(USERS_SEQ.nextval, 'LOVE', 'LOVE@NATE.COM');

INSERT INTO USERS--(ID, USERNAME, EMAIL)이렇게 다 넣을거면 생략가능하다
VALUES(USERS_SEQ.nextval, 'COS', 'COS@NATE.COM');

COMMIT;

SELECT * FROM USERS;

INSERT INTO BOARD(ID, TITLE, CONTENT, USERID)
VALUES(BOARD_SEQ.NEXTVAL, '오라클 1강', 'DDL이란?', 100);

INSERT INTO BOARD(ID, TITLE, CONTENT, USERID)
VALUES(BOARD_SEQ.NEXTVAL, '오라클 2강', 'DDL이란?', 100);

INSERT INTO BOARD(ID, TITLE, CONTENT, USERID)
VALUES(BOARD_SEQ.NEXTVAL, '오라클 3강', 'DDL이란?', 101);

INSERT INTO BOARD(ID, TITLE, CONTENT, USERID)
VALUES(BOARD_SEQ.NEXTVAL, '오라클 4강', 'DDL이란?', 100);

COMMIT;


DELETE FROM BOARD;
DELETE FROM USERS;

DROP SEQUENCE BOARD_SEQ;
DROP SEQUENCE USERS_SEQ;

CREATE SEQUENCE users_seq
INCREMENT BY 1
START WITH 1; 

CREATE SEQUENCE board_seq
INCREMENT BY 1
START WITH 1;
-- DDL ( 테이블 삭제(drop), 수정(alter), 생성(create))
INSERT INTO USERS(ID, USERNAME, EMAIL) 
VALUES(USERS_SEQ.nextval, 'ssar', 'ssar@nate.com');

INSERT INTO USERS(ID, USERNAME, EMAIL) 
VALUES(USERS_SEQ.nextval, 'love', 'love@nate.com');

INSERT INTO USERS(ID, USERNAME, EMAIL) 
VALUES(USERS_SEQ.nextval, 'cos', 'cos@nate.com');

commit;

SELECT * FROM USERS;

INSERT INTO BOARD(ID, TITLE, CONTENT, USERID) 
VALUES(BOARD_SEQ.nextval, '오라클 1강', 'DDL이란?', 1);

INSERT INTO BOARD(ID, TITLE, CONTENT, USERID) 
VALUES(BOARD_SEQ.nextval, '오라클 2강', 'DML이란?', 1);

INSERT INTO BOARD(ID, TITLE, CONTENT, USERID) 
VALUES(BOARD_SEQ.nextval, '오라클 3강', 'DCL이란?', 2);

INSERT INTO BOARD(ID, TITLE, CONTENT, USERID) 
VALUES(BOARD_SEQ.nextval, '오라클 4강', 'DQL이란?', 1);

COMMIT;

SELECT *  FROM BOARD;

INSERT INTO REPLY(ID, CONTENT, BOARDID, USERID)
VALUES (REPLY_SEQ.NEXTVAL, '재밌어요', 1,1);
INSERT INTO REPLY(ID, CONTENT, BOARDID, USERID)
VALUES (REPLY_SEQ.NEXTVAL, '진짜 재밌어요', 1,2);
COMMIT;

SELECT *
FROM REPLY;

--조인
SELECT * 
FROM USERS U, BOARD B
WHERE U.ID = B.USERID;

--3번 유저가 나오게!! LEFT OUTER JOIN
SELECT * 
FROM USERS U, BOARD B
WHERE U.ID = B.USERID(+);

--
SELECT *
FROM USERS U, REPLY R
WHERE U.ID = R.USERID;

--누가 안적었나
SELECT *
FROM USERS U, REPLY R
WHERE U.ID = R.USERID(+)
AND R.ID IS NULL;

--누가 안적었나
SELECT *
FROM USERS U, REPLY R
WHERE U.ID = R.USERID(+)
AND R.ID IS NULL
minus
SELECT *
FROM USERS U, REPLY R
WHERE U.ID = R.USERID;

SELECT B.ID, B.TITLE, B.USERID, COUNT(R.ID) "댓글수"
FROM BOARD B, REPLY R
WHERE B.ID = R.BOARDID(+)
GROUP BY B.ID, B.TITLE, B.USERID;

SELECT ID, TITLE, USERID,
(SELECT COUNT(*) FROM REPLY WHERE BOARDID = B.ID) "댓글수"
FROM BOARD B;

SELECT B.ID, B.TITLE, U.USERNAME, COUNT(R.ID) "댓글수"
FROM BOARD B, REPLY R, USERS U
WHERE B.ID = R.BOARDID(+) AND B.USERID = U.ID
GROUP BY B.ID, B.TITLE, U.USERNAME;

-----------20200402
SELECT *
FROM EMP;
--SELF JOIN- 내 테이블 2개 놔두고 INNER JOIN
SELECT E1.EMPNO, E1.ENAME, E1.JOB, E2.MGR, E2.ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO(+);
--ANSI JOIN
--INNER JOIN 오라클
SELECT E.EMPNO, E.ENAME, E.DEPTNO, D.DNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;
--ANSI
SELECT E.EMPNO, E.ENAME, E.DEPTNO, D.DNAME
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO AND E.DEPTNO = 10;
--ANSI
SELECT E.EMPNO, E.ENAME, E.DEPTNO, D.DNAME
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO 
WHERE E.DEPTNO = 10;
--그냥 INNER JOIN (비교하기위해서)
SELECT *
FROM BOARD B, REPLY R
WHERE B.ID = R.BOARDID;
--ANSI JOIN  왼쪽 기준으로
SELECT *
FROM BOARD B LEFT OUTER JOIN REPLY R
ON B.ID = R.BOARDID;
--ANSI JOIN 오른쪽 기준으로
SELECT *
FROM BOARD B RIGHT OUTER JOIN REPLY R
ON B.ID = R.BOARDID;
--ANSI JOIN 양쪽 다 뽑고 싶으면
SELECT *
FROM BOARD B FULL OUTER JOIN REPLY R
ON B.ID = R.BOARDID;